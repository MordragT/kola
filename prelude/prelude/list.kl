{
    # High-frequency, low-level operations - direct builtins
    export length : forall a . List a -> Num = list_length,
    export is_empty : forall a . List a -> Bool = list_is_empty,

    # High-frequency, low-level operations - wrapped builtins
    export prepend : forall a . a -> List a -> List a = fn head =>
        fn tail_list => (list_prepend { head = head, tail = tail_list }),

    export append : forall a . List a -> a -> List a = fn head_list =>
        fn tail => (list_append { head = head_list, tail = tail }),

    # Map implementation using recursion effect
    export map : forall a b . (a -> b) -> List a -> List b = fn f => fn list =>
        let mapper = (map_impl f) in
        let handled = handle mapper
            | recurse call => ((call.self call.f) call.tail) in  # Runtime handles the recursive call
        (handled list),

    map_impl = fn f => fn list => case list
        | [] => []
        | [head, ...tail] =>
            let mapped_head = (f head) in
            let mapped_tail = do recurse { self = (lookup @map_impl), f = f, tail = tail } in
            ((prepend mapped_head) mapped_tail),

    # filter, append, prepend, reverse
}
