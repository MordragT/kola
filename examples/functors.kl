{
    module type Randomize = {
        rand : Num -> Num,
    },

    export module rand_a = {
        rand = fn x => x + 1,
    },

    export module rand_b = {
        rand = fn x => x * 2,
    },

    module functor combined_rand ab : { module a : Randomize, module b : Randomize } => {
        rand = fn x => (ab::a::rand (ab::b::rand x)),
    },

    # For this to work I will need proper lexical scoping of inline modules
    #module input = {
    #    export module a = rand_a, # Note here not super::rand_a but just rand_a
    #    export module b = rand_b,
    #},
    module input = {
        export module a = {
            rand = fn x => x + 1,
        }, #m14
        export module b = {
            rand = fn x => x * 2,
        }, #m17
    }, # m13
    module rand_ab = (combined_rand input), # m20

    # Due to current limitations inline modules cannot be used as functor arguments
    #module rand_ab = (combined_rand { module a = rand_a, module b = rand_b }),

    main = let x = 10 in (rand_ab::rand x),


    module type Iterable = {
        map : forall a b . (a -> b) -> List a -> List b,
    },
}
