{
    #add_one = fn x => x + 1,

    #main = 15 |> add_one |> add_one |> add_one,
    #main = add_one <| add_one <| add_one <| 15,
    #main = (add_one (add_one (add_one 15))),

    #main = let r = { a = { b = { c = "hello" } } } in r.a.b.c,


    #this doesn't work currently, because effects are currently just discarded
    #effectful : Str -> Unit ~ Io = fn x => do print x,

    #effect type Io = {
    #    print : Str -> Unit,
    #    read : Unit -> Str,
    #},

    #effectful : Unit -> Str = fn x => do read (),

    #simple = handle effectful
    #   | read arg => "Hello from read",

    #main = (simple ()),

    #main = let x = 0 in case x
    #    | 0 => "zero"
    #    | n => (case n | _ => "other"),

    #opt = None,

    #main = case opt
    #    | < None > => "No value"
    #    | < Some: v > => "Value"
    #    | _ => "Unknown case",

    #module test = {
    #    private_pi = 3.14,
    #},

    #main = test::private_pi,

    #al = [1, 2, 3],
    #bl = [4, 5, 6],

    #main = bl ++ al,

    #a = { a = { m = 3 }, b = 2 },
    #b = { a = { n = 4 }, d = 4 },

    #main = a & b,

    #type Person = {
    #    name : Str,
    #    age : Num,
    #},

    #f = fn x => x,

    #main = @Person,

    #export effect type Test = {
    #    test : Num -> Person,
    #},

    #type Test = with label l . forall record r . { @l : Num | r },


    #row_id label l : forall record r . r = fn r => r,
    # pros: partial inference feels natural,
    # more explicit that a value position type expr must be provided
    # type function in type bind doesn't make sense
    # cons: could look like a term parameter not a type parameter

    #type Test label l = forall record r . { @label : Num | r },

    #insert : with label l . forall a record r . a -> r -> { @l : a | r } = fn a => fn r => { r | +@l = a },

    #insert_num : forall record r . Num -> r -> { num : Num | r } = fn n => fn r => (insert 'num n r),

    row_id : forall label l record r . r = fn l => fn r => r,

    main = (row_id 'num { a = 1, b = 2, c = 3 }),
}
