# let sg = \a => if a == 0 then true else false in
#    (sg true)

#let id = \a => a in
#    {
#        a = (id true),
#        b = (id (id 10)),
#    }

#let Y = \f =>
#    let g = \x => (f (x x)) in
#    (g g)
#in
#let fact = \f => \n => if n == 0 then 1 else n * (f n - 1) in
#((Y fact) 5)

#let r = { a = 10, b = 20 } in
#    #{ r | -a }
#    #{ r | a = "test" }
#    { r | +c = 20 | +d = 30 }


#let f = \a => \b => a + b in
#    ((f 10) 5)

#let x =
#    let y =
#        let z = 10 in z
#    in y
#in x

{
    module str = import str,
    module cyclic = import cyclic,

    type Option = forall a . < Some : a, None >,

    type Person = { name : Str, age : Num },

    type NestedPerson = { id : Num, info : { age : Num } },

    main = let p = { id = 0, info = { age = 25 } } in { p | info.age += 1 }, # record update should also allow record field selections
    # currently would be: in { p | info = { p.info | age += 1 } },

    age : Person -> Person = fn person => { person | age += 1 },

    module test = {
        test_age =
            let peter = { name = "peter", age = 25 } in
            let some_peter = (Some peter) in
            let older_peter = (age peter) in
            older_peter.age == peter.age + 1,
    },
}
